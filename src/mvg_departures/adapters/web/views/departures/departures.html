<!-- Viewport meta tag to prevent zooming on iOS devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
<!-- Minimal DaisyUI for theme support only -->
<link href="https://cdn.jsdelivr.net/npm/daisyui@5" rel="stylesheet" type="text/css" />
<script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
<script>
    // Apply theme based on configuration
    const themeConfig = ('{{ theme }}' && '{{ theme }}' !== 'undefined' && '{{ theme }}' !== '') ? '{{ theme }}' : 'auto';
    if (themeConfig === 'light') {
        document.documentElement.setAttribute('data-theme', 'light');
        localStorage.theme = 'light';
    } else if (themeConfig === 'dark') {
        document.documentElement.setAttribute('data-theme', 'dark');
        localStorage.theme = 'dark';
    } else {
        // Auto: follow system preference
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.setAttribute('data-theme', 'dark');
        } else {
            document.documentElement.setAttribute('data-theme', 'light');
        }
    }
</script>
<style>
    * {
        box-sizing: border-box;
    }
    html, body {
        height: 100vh;
        width: 100vw;
        margin: 0;
        padding: 0;
        overflow: hidden;
        box-sizing: border-box;
    }
    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        line-height: 1.2;
        display: flex;
        flex-direction: column;
        height: 100vh;
        width: 100vw;
        max-width: 100vw;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    [data-theme="light"] body {
        background-color: #ffffff;
        color: #111827;
    }
    [data-theme="dark"] body {
        background-color: #1d232a;
        color: #f9fafb;
    }
    .departure-row {
        display: flex;
        align-items: center;
        padding: 0.75rem 0 0.75rem 0.75rem;
        border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        min-height: 4.5rem;
        width: 100%;
        box-sizing: border-box;
    }
    .departure-row:nth-child(even) {
        background-color: rgba(0, 0, 0, 0.02);
    }
    [data-theme="light"] .departure-row {
        border-bottom-color: rgba(0, 0, 0, 0.08);
    }
    [data-theme="light"] .departure-row:nth-child(even) {
        background-color: rgba(0, 0, 0, 0.02);
    }
    [data-theme="dark"] .departure-row {
        border-bottom-color: rgba(255, 255, 255, 0.08);
        background-color: #1d232a;
    }
    [data-theme="dark"] .departure-row:nth-child(even) {
        background-color: rgba(255, 255, 255, 0.03);
    }
    .route-number {
        flex: 0 0 5rem;
        font-weight: 700;
        font-size: {{ font_size_route_number }};
        text-align: left;
        padding: 0 0.75rem 0 0;
        white-space: nowrap;
    }
    [data-theme="light"] .route-number {
        color: #1f2937;
    }
    [data-theme="dark"] .route-number {
        color: #f3f4f6;
    }
    .destination {
        flex: 1 1 auto;
        overflow-x: hidden;
        overflow-y: hidden;
        white-space: nowrap;
        padding: 0 0.75rem;
        min-width: 0;
        font-size: {{ font_size_destination }};
        font-weight: 500;
        text-align: left;
    }
    .destination-text {
        display: inline-block;
        white-space: nowrap;
    }
    /* Auto-scroll animation for clipped destination text */
    /* Only applies when .clipped class is present (added by JS when text overflows) */
    @keyframes scroll-destination {
        0%, 30% {
            transform: translateX(0);
        }
        50%, 70% {
            /* Scroll distance is set dynamically via CSS variable --scroll-distance */
            transform: translateX(var(--scroll-distance, -18%));
        }
        100% {
            transform: translateX(0);
        }
    }
    .destination-text.clipped {
        animation: scroll-destination 20s ease-in-out infinite;
        will-change: transform;
    }
    /* Pause animation on interaction for better UX */
    .destination:hover .destination-text.clipped,
    .destination:active .destination-text.clipped,
    .departure-row:hover .destination-text.clipped {
        animation-play-state: paused;
    }
    [data-theme="light"] .destination {
        color: #374151;
    }
    [data-theme="dark"] .destination {
        color: #e5e7eb;
    }
    .platform {
        flex: 0 0 auto;
        font-size: {{ font_size_platform }};
        font-weight: 400;
        text-align: left;
        padding: 0 0.75rem;
        white-space: nowrap;
        min-width: fit-content;
        color: #6b7280;
    }
    [data-theme="light"] .platform {
        color: #6b7280;
    }
    [data-theme="dark"] .platform {
        color: #9ca3af;
    }
    .time {
        flex: 0 0 auto;
        text-align: right;
        font-weight: 600;
        font-size: {{ font_size_time }};
        padding: 0 0.75rem 0 0.75rem;
        margin-right: 0;
        white-space: nowrap;
        min-width: fit-content;
        overflow: hidden;
        transition: opacity 0.3s ease-in-out;
    }
    [data-theme="light"] .time {
        color: #111827;
    }
    [data-theme="dark"] .time {
        color: #f9fafb;
    }
    .no-departures {
        width: 100%;
        text-align: center;
        font-size: {{ font_size_no_departures }};
        color: #9ca3af;
        padding: 2rem 0;
        font-style: italic;
    }
    [data-theme="light"] .no-departures {
        color: #6b7280;
    }
    [data-theme="dark"] .no-departures {
        color: #6b7280;
    }
    .direction-header {
        font-size: {{ font_size_direction_header }};
        font-weight: 700;
        margin: 0.5rem 0 0.25rem 0;
        padding: 0 0.75rem 0.25rem 0.75rem;
        border-bottom: 2px solid rgba(0, 0, 0, 0.2);
        opacity: 0.85;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
    }
    h2.direction-header {
        margin: 0.5rem 0 0.25rem 0;
        padding: 0 0.75rem 0.25rem 0.75rem;
    }
    .direction-header-text {
        flex: 1;
        min-width: 0;
    }
    .direction-header-status-group {
        display: flex;
        align-items: center;
        gap: 0.25rem;
        flex-shrink: 0;
        margin-right: 0.25rem;
        font-size: inherit;
    }
    .direction-header-time {
        flex-shrink: 0;
        margin-left: auto; /* Push to right */
        white-space: nowrap;
        display: flex;
        align-items: center; /* Vertical alignment */
        line-height: 1; /* Match header text line height */
    }
    [data-theme="light"] .direction-header {
        background-color: {{ banner_color }};
        color: #ffffff;
        border-bottom-color: rgba(255, 255, 255, 0.25);
    }
    [data-theme="dark"] .direction-header {
        color: #f3f4f6;
        border-bottom-color: rgba(255, 255, 255, 0.15);
    }
    .route-group-header {
        height: 0.15em;
        line-height: 0.15em;
        margin: 0.15rem 0.5rem;
        border-top: 1px solid rgba(0, 0, 0, 0.08);
        opacity: 0.4;
    }
    [data-theme="light"] .route-group-header {
        border-top-color: rgba(0, 0, 0, 0.1);
    }
    [data-theme="dark"] .route-group-header {
        border-top-color: rgba(255, 255, 255, 0.08);
    }
    .pagination-container {
        position: relative;
        overflow: hidden;
        min-height: 3rem;
    }
    .pagination-page {
        display: none;
        animation: fadeIn 0.5s ease-in;
    }
    .pagination-page.active {
        display: block;
    }
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    .pagination-indicator {
        position: absolute;
        top: 0.5rem;
        right: 0.5rem;
        padding: 0.6rem 0.8rem;
        border-radius: 0.5rem;
        font-size: {{ font_size_pagination_indicator }};
        font-weight: 600;
        z-index: 10;
        display: flex;
        align-items: center;
        gap: 0.75rem;
    }
    .countdown-text {
        font-size: {{ font_size_countdown_text }};
        font-weight: 500;
        min-width: 2.5rem;
        text-align: center;
    }
    [data-theme="light"] .pagination-indicator {
        background: rgba(0, 0, 0, 0.75);
        color: #ffffff;
    }
    [data-theme="dark"] .pagination-indicator {
        background: rgba(255, 255, 255, 0.2);
        color: #ffffff;
    }
    .countdown-circle {
        width: 1.4rem;
        height: 1.4rem;
        border-radius: 50%;
        border: 2px solid currentColor;
        position: relative;
        display: inline-block;
    }
    .countdown-circle svg {
        width: 100%;
        height: 100%;
        transform: rotate(-90deg);
    }
    .countdown-circle circle {
        fill: none;
        stroke: currentColor;
        stroke-width: 2.5;
        stroke-dasharray: 31.416;
        stroke-dashoffset: 0;
        transition: stroke-dashoffset 0.1s linear;
    }
    .direction-group-container {
        position: relative;
        overflow: visible;
    }
    .stop-header {
        font-size: {{ font_size_stop_header }};
        font-weight: 700;
        margin: 0.5rem 0.5rem 0.25rem 0.5rem;
        padding: 0;
        opacity: 0.95;
    }
    [data-theme="light"] .stop-header {
        color: #111827;
    }
    [data-theme="dark"] .stop-header {
        color: #f9fafb;
    }
    .cancelled {
        opacity: 0.5;
        text-decoration: line-through;
    }
    .delay {
        color: #d97706;
    }
    [data-theme="light"] .delay {
        color: #b45309;
    }
    [data-theme="dark"] .delay {
        color: #fbbf24;
    }
    .delay-amount {
        color: #dc2626;
        font-size: {{ font_size_delay_amount }};
        font-weight: 500;
        margin-left: 0.5rem;
    }
    [data-theme="light"] .delay-amount {
        color: #dc2626;
    }
    [data-theme="dark"] .delay-amount {
        color: #f87171;
    }
    .realtime {
        color: #059669;
    }
    [data-theme="light"] .realtime {
        color: #047857;
    }
    [data-theme="dark"] .realtime {
        color: #34d399;
    }
    .container {
        width: 100vw !important;
        max-width: 100vw !important;
        height: 100vh;
        margin: 0 !important;
        padding: 0 !important;
        flex: 1 1 100%;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        box-sizing: border-box;
    }
    [data-theme="light"] .container {
        background-color: #ffffff;
    }
    [data-theme="dark"] .container {
        background-color: #1d232a;
    }
    .header-section {
        display: none; /* Hide header to save space */
    }
    h1 {
        display: none; /* Hide title */
    }
    .last-update {
        display: none; /* Hide last update to save space */
    }
    .stop-section {
        width: 100%;
    }
    .direction-group {
        width: 100%;
    }
    .route-group {
        width: 100%;
    }
    #departures {
        flex: 1 1 100%;
        overflow-y: auto;
        overflow-x: hidden;
        position: relative;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
        padding: 0;
        margin: 0;
    }
    .status-header {
        display: flex;
        align-items: center;
        gap: 0.25rem;
        pointer-events: none;
    }
    .status-header-item {
        display: flex;
        align-items: center;
        gap: 0.25rem;
        font-size: {{ font_size_status_header }};
        font-weight: 500;
    }
    #datetime-display {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        font-variant-numeric: tabular-nums;
        letter-spacing: 0.01em;
        vertical-align: baseline;
    }
    [data-theme="light"] .status-header-item {
        color: #ffffff;
    }
    [data-theme="dark"] .status-header-item {
        color: #f3f4f6;
    }
    .status-icon.connected {
        color: #059669;
    }
    [data-theme="light"] .status-icon.connected {
        color: #047857;
    }
    [data-theme="dark"] .status-icon.connected {
        color: #34d399;
    }
    .status-icon.disconnected {
        color: #dc2626;
    }
    [data-theme="light"] .status-icon.disconnected {
        color: #dc2626;
    }
    [data-theme="dark"] .status-icon.disconnected {
        color: #f87171;
    }
    .status-icon.connecting {
        color: #d97706;
        animation: pulse-connecting 2s ease-in-out infinite;
    }
    [data-theme="light"] .status-icon.connecting {
        color: #b45309;
    }
    [data-theme="dark"] .status-icon.connecting {
        color: #fbbf24;
    }
    .status-icon.unstable {
        color: #f59e0b;
        animation: rotate-unstable 2s linear infinite;
    }
    [data-theme="light"] .status-icon.unstable {
        color: #d97706;
    }
    [data-theme="dark"] .status-icon.unstable {
        color: #fbbf24;
    }
    @keyframes pulse-connecting {
        0%, 100% {
            opacity: 1;
        }
        50% {
            opacity: 0.5;
        }
    }
    @keyframes rotate-unstable {
        from {
            transform: rotate(0deg);
        }
        to {
            transform: rotate(360deg);
        }
    }
    .status-icon.error {
        color: #ffffff;
    }
    [data-theme="light"] .status-icon.error {
        color: #ffffff;
    }
    [data-theme="dark"] .status-icon.error {
        color: #f3f4f6;
    }
    /* Floating status box at center bottom */
    .status-floating-box {
        position: fixed;
        bottom: 1rem;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.4rem 0.6rem;
        background-color: rgba(128, 128, 128, 0.3);
        backdrop-filter: blur(4px);
        border-radius: 0.4rem;
        z-index: 1000;
    }
    /* GitHub icon link inside status bar */
    .status-floating-box-github {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 1em;
        height: 1em;
        min-width: 1em;
        min-height: 1em;
        flex-shrink: 0;
        text-decoration: none;
        transition: opacity 0.2s;
    }
    .status-floating-box-github:hover {
        opacity: 0.8;
    }
    .status-floating-box-github svg {
        width: 100%;
        height: 100%;
        display: block;
    }
    [data-theme="light"] .status-floating-box-github svg {
        color: #000000;
    }
    [data-theme="dark"] .status-floating-box-github svg {
        color: #ffffff;
    }
    [data-theme="light"] .status-floating-box {
        background-color: rgba(128, 128, 128, 0.2);
    }
    [data-theme="dark"] .status-floating-box {
        background-color: rgba(128, 128, 128, 0.4);
    }
    .status-floating-box-item {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 1em;
        height: 1em;
        min-width: 1em;
        min-height: 1em;
        flex-shrink: 0;
    }
    #presence-count {
        width: auto;
        min-width: auto;
        height: 1em;
        display: flex;
        align-items: center;
        gap: 0.25rem;
        padding: 0 0.3rem;
    }
    .status-floating-box-presence {
        margin-left: auto; /* Push to the right */
    }
    .presence-icon {
        width: 1em;
        height: 1em;
        flex-shrink: 0;
    }
    .presence-count-text {
        font-size: 1.2em;
        font-weight: 500;
        white-space: nowrap;
        font-variant-numeric: tabular-nums;
        line-height: 1;
    }
    [data-theme="light"] .presence-count-text,
    [data-theme="light"] .presence-icon {
        color: #111827;
    }
    [data-theme="dark"] .presence-count-text,
    [data-theme="dark"] .presence-icon {
        color: #f9fafb;
    }
    /* All status icons same size - 1em */
    .status-icon, .api-status-icon {
        width: 100%;
        height: 100%;
        display: block;
    }
    .refresh-countdown svg {
        width: 100%;
        height: 100%;
        display: block;
    }
    .refresh-countdown circle {
        fill: none;
        stroke-width: 2;
        transition: stroke-dashoffset 0.1s linear;
    }
    [data-theme="light"] .refresh-countdown circle {
        stroke: rgba(0, 0, 0, 0.3);
    }
    [data-theme="light"] .refresh-countdown circle.progress {
        stroke: rgba(0, 0, 0, 0.8);
    }
    [data-theme="dark"] .refresh-countdown circle {
        stroke: rgba(255, 255, 255, 0.3);
    }
    [data-theme="dark"] .refresh-countdown circle.progress {
        stroke: rgba(255, 255, 255, 0.8);
    }
    .api-status-icon.api-success {
        color: #059669;
    }
    [data-theme="light"] .api-status-icon.api-success {
        color: #047857;
    }
    [data-theme="dark"] .api-status-icon.api-success {
        color: #34d399;
    }
    .api-status-icon.api-error {
        color: #dc2626;
    }
    [data-theme="light"] .api-status-icon.api-error {
        color: #dc2626;
    }
    [data-theme="dark"] .api-status-icon.api-error {
        color: #f87171;
    }
    .api-status-icon.api-unknown {
        color: rgba(255, 255, 255, 0.5);
    }
    [data-theme="light"] .api-status-icon.api-unknown {
        color: rgba(0, 0, 0, 0.3);
    }
    [data-theme="dark"] .api-status-icon.api-unknown {
        color: rgba(255, 255, 255, 0.3);
    }
    /* Screen reader only class */
    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
    }
    /* Skip link for keyboard navigation */
    .skip-link {
        position: absolute;
        top: -40px;
        left: 0;
        background: #000;
        color: #fff;
        padding: 8px;
        text-decoration: none;
        z-index: 100;
    }
    .skip-link:focus {
        top: 0;
    }
    /* Ensure list items maintain departure-row styling */
    .departure-row {
        list-style: none;
    }
    /* Mobile responsive font sizes - reduce on phones for better fit */
    @media (max-width: 768px) {
        .route-number {
            font-size: calc({{ font_size_route_number }} * 0.75);
        }
        .destination {
            font-size: calc({{ font_size_destination }} * 0.75);
        }
        .platform {
            font-size: calc({{ font_size_platform }} * 0.75);
        }
        .time {
            font-size: calc({{ font_size_time }} * 0.75);
        }
        .direction-header {
            font-size: calc({{ font_size_direction_header }} * 0.75);
        }
        .stop-header {
            font-size: calc({{ font_size_stop_header }} * 0.75);
        }
        .no-departures {
            font-size: calc({{ font_size_no_departures }} * 0.75);
        }
        .pagination-indicator {
            font-size: calc({{ font_size_pagination_indicator }} * 0.75);
        }
        .countdown-text {
            font-size: calc({{ font_size_countdown_text }} * 0.75);
        }
        .status-header-item {
            font-size: calc({{ font_size_status_header }} * 0.75);
        }
        .delay-amount {
            font-size: calc({{ font_size_delay_amount }} * 0.75);
        }
    }
    /* Extra small phones (iPhone 13 mini, etc.) - more aggressive reduction */
    @media (max-width: 400px) {
        .route-number {
            font-size: calc({{ font_size_route_number }} * 0.55);
        }
        .destination {
            font-size: calc({{ font_size_destination }} * 0.65);
        }
        .platform {
            font-size: calc({{ font_size_platform }} * 0.65);
        }
        .time {
            font-size: calc({{ font_size_time }} * 0.55);
        }
        .direction-header {
            font-size: calc({{ font_size_direction_header }} * 0.65);
        }
        .stop-header {
            font-size: calc({{ font_size_stop_header }} * 0.65);
        }
        .no-departures {
            font-size: calc({{ font_size_no_departures }} * 0.65);
        }
        .pagination-indicator {
            font-size: calc({{ font_size_pagination_indicator }} * 0.65);
        }
        .countdown-text {
            font-size: calc({{ font_size_countdown_text }} * 0.65);
        }
        .status-header-item {
            font-size: calc({{ font_size_status_header }} * 0.65);
        }
        .delay-amount {
            font-size: calc({{ font_size_delay_amount }} * 0.65);
        }
    }
</style>
</head>
<body class="min-h-screen bg-base-100" style="width: 100vw; max-width: 100vw; margin: 0; padding: 0;">
<!-- Skip to main content link for keyboard navigation -->
<a href="#departures" class="skip-link">Skip to main content</a>

<!-- ARIA live region for status announcements -->
<div id="aria-live-status" aria-live="polite" aria-atomic="true" class="sr-only"></div>
<!-- ARIA live region for departure updates -->
<div id="aria-live-departures" aria-live="polite" aria-atomic="false" class="sr-only"></div>

<div class="container" data-phx-main role="main" aria-label="MVG Departures Dashboard">
    <div class="header-section">
        <h1>MVG Departures</h1>
        <div class="last-update" aria-live="polite" aria-atomic="true">
            Last updated: {{ update_time }}
        </div>
    </div>

    <div id="departures" role="region" aria-label="Departure information" aria-live="polite" aria-atomic="false">
        {% if not has_departures %}
        <div role="status" aria-live="polite" style="text-align: center; padding: 4rem 2rem; opacity: 0.7; font-size: {{ font_size_no_departures }}; font-weight: 500;">No departures available</div>
        {% else %}
        {% for group in groups_with_departures %}
        <div class="direction-group">
            <h2 class="direction-header" role="heading" aria-level="2">
                {% if group.is_first_header %}
                <span class="direction-header-text">{{ group.header }}</span>
                <div class="direction-header-time status-header-item" id="datetime-display" aria-label="Current date and time"></div>
                {% else %}
                {{ group.header }}
                {% endif %}
            </h2>
            <ul role="list" aria-label="Departures for {{ group.header }}">
                {% for departure in group.departures %}
                <li class="departure-row{% if departure.cancelled %} cancelled{% endif %}" role="listitem" aria-label="{{ departure.aria_label }}">
                    <div class="route-number" aria-hidden="true">{{ departure.line }}</div>
                    <div class="destination" aria-hidden="true"><span class="destination-text">{{ departure.destination }}</span></div>
                    <div class="platform" aria-hidden="true">{% if departure.platform %}{{ departure.platform }}{% endif %}</div>
                    <div class="time{% if departure.has_delay %} delay{% endif %}{% if departure.is_realtime %} realtime{% endif %}" aria-hidden="true" data-time-relative="{{ departure.time_str_relative }}" data-time-absolute="{{ departure.time_str_absolute }}">
                        {{ departure.time_str_relative }}{% if departure.delay_display %}{{ departure.delay_display }}{% endif %}
                    </div>
                    <span class="sr-only">{{ departure.aria_label }}</span>
                </li>
                {% endfor %}
            </ul>
        </div>
        {% endfor %}
        {% for stop_name in stops_without_departures %}
        <div class="direction-group">
            <h2 class="direction-header" role="heading" aria-level="2">{{ stop_name }}</h2>
            <div class="departure-row" role="status" aria-live="polite">
                <div class="no-departures">No departures</div>
            </div>
        </div>
        {% endfor %}
        {% endif %}
    </div>

    <!-- Floating status box at bottom center -->
    <div class="status-floating-box" role="status" aria-label="System status indicators: connection status, API status, refresh countdown, and user presence">
        <div class="status-floating-box-item" id="connection-status" data-connection-state="connecting" role="img" aria-label="Connection status: connecting" title="WebSocket connection status">
            <!-- Connected: bolt icon -->
            <svg class="status-icon connected" id="connected-icon" style="display: none;" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 13.5l10.5-11.25L12 10.5h8.25L9.75 21.75 12 13.5H3.75z" />
            </svg>
            <!-- Disconnected: bolt-slash icon -->
            <svg class="status-icon disconnected" id="disconnected-icon" style="display: none;" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" d="M11.412 15.655L9.75 21.75l3.192-2.328a.75.75 0 00.945.059l5.25-3.75a.75.75 0 00-.412-1.33l-2.728-.182-3.432-3.432a.75.75 0 00-.675-.248L3.75 13.5l7.662-8.25m8.25 0L12 10.5H3.75l5.25-3.75L9.75 3l-1.5 4.5" />
            </svg>
            <!-- Connecting: signal icon (pulsing) -->
            <svg class="status-icon connecting" id="connecting-icon" style="display: none;" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" d="M9.348 14.651a3.75 3.75 0 010-5.303m5.304 0a3.75 3.75 0 010 5.303m-7.425 2.122a6.75 6.75 0 010-9.546m9.546 0a6.75 6.75 0 010 9.546M5.106 18.894c-3.808-3.808-3.808-9.98 0-13.789m13.788 0c3.808 3.808 3.808 9.981 0 13.79M12 12h.008v.007H12V12z" />
            </svg>
            <!-- Unstable/Degraded: question-mark-circle icon (for botched updates/disconnections) -->
            <svg class="status-icon unstable" id="unstable-icon" style="display: none;" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" d="M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9 5.25h.008v.008H12v-.008z" />
            </svg>
        </div>
        <div class="status-floating-box-item" id="api-status-container" role="img" aria-label="API status: unknown" title="MVG API connection status">
            <!-- Success: check-circle icon -->
            <svg class="api-status-icon api-success" id="api-success-icon" style="display: none;" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <!-- Error: x-circle icon -->
            <svg class="api-status-icon api-error" id="api-error-icon" style="display: none;" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" d="M9.75 9.75l4.5 4.5m0-4.5l-4.5 4.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <!-- Unknown: question-mark-circle icon -->
            <svg class="api-status-icon api-unknown" id="api-unknown-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" d="M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9 5.25h.008v.008H12v-.008z" />
            </svg>
        </div>
        <div class="status-floating-box-item refresh-countdown" role="img" aria-label="Refresh countdown timer" title="Time until next data refresh" data-last-update='{{ last_update_timestamp }}'>
            <svg viewBox="0 0 12 12" width="100%" height="100%" aria-hidden="true">
                <circle cx="6" cy="6" r="5" class="background"></circle>
                <circle cx="6" cy="6" r="5" class="progress" transform="rotate(-90 6 6)"></circle>
            </svg>
            <span class="sr-only" id="refresh-countdown-sr">Refresh countdown timer</span>
        </div>
        <!-- GitHub icon on the right side of status bar -->
        <a href="https://github.com/d-led/my-mvg-departures" target="_blank" rel="noopener noreferrer" class="status-floating-box-github status-floating-box-item" aria-label="View repository on GitHub (opens in new tab)" title="View repository on GitHub">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="currentColor" aria-hidden="true">
                <path d="M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.46-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z"/>
            </svg>
            <span class="sr-only">View repository on GitHub</span>
        </a>
        <!-- Presence count display (rightmost) -->
        <div class="status-floating-box-item status-floating-box-presence" id="presence-count" role="status" aria-label="Users online: {{ presence_local }} on this dashboard, {{ presence_total }} total across all dashboards" title="{{ presence_local }} users on this dashboard, {{ presence_total }} users total across all dashboards">
            <svg class="presence-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" d="M15 19.128a9.38 9.38 0 002.625.372 9.337 9.337 0 004.121-.952 4.125 4.125 0 00-7.533-2.493M15 19.128v-.003c0-1.113-.285-2.16-.786-3.07M15 19.128v.106A12.318 12.318 0 018.624 21c-2.331 0-4.512-.645-6.374-1.766l-.001-.109a6.375 6.375 0 0111.964-3.07M12 6.375a3.375 3.375 0 11-6.75 0 3.375 3.375 0 016.75 0zm8.25 2.25a2.625 2.625 0 11-5.25 0 2.625 2.625 0 015.25 0z" />
            </svg>
            <span class="presence-count-text" aria-hidden="true">{{ presence_local }}/{{ presence_total }}</span>
            <span class="sr-only">{{ presence_local }} users on this dashboard, {{ presence_total }} users total across all dashboards</span>
        </div>
    </div>
</div>

<script>
    // Suppress pyview debug logging (mount/update events from app.js)
    // This must run before app.js loads to intercept its console.log calls
    (function() {
        const originalLog = console.log;
        console.log = function(...args) {
            // Filter out pyview debug logs (mount/update events)
            // Pattern: "phx-<id> mount:" or "phx-<id> update:"
            const message = args.join(' ');
            if (message.match(/phx-[a-f0-9-]+\s+(mount|update):/)) {
                return; // Suppress these logs
            }
            originalLog.apply(console, args);
        };
    })();

    // Prevent zooming on iOS devices, especially when unlocking
    (function() {
        // Reset zoom on visibility change (when device is unlocked)
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden) {
                // Reset zoom by setting viewport scale
                const viewport = document.querySelector('meta[name="viewport"]');
                if (viewport) {
                    viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover');
                }
                // Force a reflow to ensure zoom is reset
                void document.body.offsetHeight;
            }
        });
        // Also reset zoom on focus (when app comes to foreground)
        window.addEventListener('focus', function() {
            const viewport = document.querySelector('meta[name="viewport"]');
            if (viewport) {
                viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover');
            }
            void document.body.offsetHeight;
        });
        // Prevent double-tap zoom on iOS
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function(event) {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
    })();

    // Pagination configuration
    const PAGINATION_ENABLED = '{{ pagination_enabled }}' === 'true';
    const DEPARTURES_PER_PAGE = parseInt('{{ departures_per_page }}') || 5;
    const PAGE_ROTATION_SECONDS = parseInt('{{ page_rotation_seconds }}') || 10;
    const REFRESH_INTERVAL_SECONDS = parseInt('{{ refresh_interval_seconds }}') || 20;
    const TIME_FORMAT_TOGGLE_SECONDS = parseInt('{{ time_format_toggle_seconds }}') || 0;
    const INITIAL_API_STATUS = ('{{ api_status }}' && '{{ api_status }}' !== 'undefined' && '{{ api_status }}' !== '') ? '{{ api_status }}' : 'unknown';

    // Date/time display
    function updateDateTime() {
        const datetimeEl = document.getElementById('datetime-display');
        if (!datetimeEl) return;

        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const seconds = String(now.getSeconds()).padStart(2, '0');

        const dateStr = year + '-' + month + '-' + day;
        const timeStr = hours + ':' + minutes + ':' + seconds;
        const fullDateTime = dateStr + ' ' + timeStr;

        datetimeEl.textContent = fullDateTime;
        datetimeEl.setAttribute('aria-label', 'Current date and time: ' + fullDateTime);
    }

    // Update date/time every second
    updateDateTime();
    setInterval(updateDateTime, 1000);

    // Time format toggle - animate text content change
    let timeFormatToggleInterval = null;
    let currentTimeFormat = 'relative';
    // TIME_FORMAT_TOGGLE_SECONDS is defined above with safe defaults

    function toggleTimeFormat() {
        if (TIME_FORMAT_TOGGLE_SECONDS <= 0) {
            // If toggle is disabled (0), show only relative format
            document.querySelectorAll('.time').forEach(el => {
                const relative = el.getAttribute('data-time-relative');
                if (relative) {
                    // Fade out, change text, fade in
                    el.style.opacity = '0';
                    setTimeout(() => {
                        const delayDisplay = el.querySelector('.delay-amount');
                        const delayHTML = delayDisplay ? delayDisplay.outerHTML : '';
                        el.innerHTML = relative + delayHTML;
                        el.style.opacity = '1';
                    }, 150);
                }
            });
            return;
        }

        const timeElements = document.querySelectorAll('.time');

        timeElements.forEach(el => {
            const relative = el.getAttribute('data-time-relative');
            const absolute = el.getAttribute('data-time-absolute');
            if (!relative || !absolute) return;

            // Store current width to prevent layout shift when longer text is inserted
            const currentWidth = el.offsetWidth;
            el.style.width = currentWidth + 'px';

            // Fade out smoothly
            el.style.opacity = '0';

            setTimeout(() => {
                // Preserve delay display if present
                const delayDisplay = el.querySelector('.delay-amount');
                const delayHTML = delayDisplay ? delayDisplay.outerHTML : '';

                // Change text content
                if (currentTimeFormat === 'relative') {
                    // Switch to absolute
                    el.innerHTML = absolute + delayHTML;
                } else {
                    // Switch to relative
                    el.innerHTML = relative + delayHTML;
                }

                // Remove fixed width to allow new content to size naturally
                el.style.width = '';

                // Fade in smoothly
                el.style.opacity = '1';
            }, 150);
        });

        currentTimeFormat = currentTimeFormat === 'relative' ? 'absolute' : 'relative';

        // Recalculate destination clipping after layout settles (time format change may affect container widths)
        setTimeout(() => {
            initDestinationScrolling();
        }, 200);
    }

    function initTimeFormatToggle() {
        // Clear any existing interval
        if (timeFormatToggleInterval) {
            clearInterval(timeFormatToggleInterval);
            timeFormatToggleInterval = null;
        }

        // Ensure all time elements start with relative format and full opacity
        document.querySelectorAll('.time').forEach(el => {
            const relative = el.getAttribute('data-time-relative');
            if (relative) {
                // Preserve existing delay display if present
                const delayDisplay = el.querySelector('.delay-amount');
                const delayHTML = delayDisplay ? delayDisplay.outerHTML : '';
                el.innerHTML = relative + delayHTML;
            }
            el.style.opacity = '1';
        });

        if (TIME_FORMAT_TOGGLE_SECONDS > 0) {
            // Start with relative format
            currentTimeFormat = 'relative';

            // Toggle every TIME_FORMAT_TOGGLE_SECONDS
            timeFormatToggleInterval = setInterval(toggleTimeFormat, TIME_FORMAT_TOGGLE_SECONDS * 1000);
        }
    }

    // Connection status monitoring
    // States: connecting (yellow), connected (green), unstable (orange/question-mark-circle), broken (red)
    let connectionState = 'connecting'; // Start as connecting (yellow)
    let countdownInterval = null;
    let countdownElapsed = 0;
    let countdownRunning = false;
    let lastUpdateTime = Date.now();
    let startCountdown = null; // Will be set by initRefreshCountdown
    let updateTimeout = null; // Timeout to detect when updates stop arriving
    let failedUpdateCount = 0; // Track consecutive failed updates
    let lastSuccessfulUpdate = Date.now(); // Track last successful update
    // No reconnectTimeout - PyView handles reconnection, we just listen to events

    function updateConnectionStatus() {
        const connectionEl = document.getElementById('connection-status');
        if (!connectionEl) {
            // console.warn('connection-status element not found');
            return;
        }

        const connectedIcon = connectionEl.querySelector('#connected-icon');
        const disconnectedIcon = connectionEl.querySelector('#disconnected-icon');
        const connectingIcon = connectionEl.querySelector('#connecting-icon');
        const unstableIcon = connectionEl.querySelector('#unstable-icon');
        const liveRegion = document.getElementById('aria-live-status');

        if (!connectedIcon || !disconnectedIcon || !connectingIcon || !unstableIcon) {
            // console.warn('Connection status icons not found');
            return;
        }

        // Update data attribute to preserve state across DOM updates
        connectionEl.setAttribute('data-connection-state', connectionState);

        // Hide all icons first
        connectedIcon.style.display = 'none';
        disconnectedIcon.style.display = 'none';
        connectingIcon.style.display = 'none';
        unstableIcon.style.display = 'none';

        // Explicitly remove animation to stop any running animations
        connectingIcon.style.animation = 'none';
        unstableIcon.style.animation = 'none';
        // Force a reflow to ensure animation is stopped
        void connectingIcon.offsetHeight;
        void unstableIcon.offsetHeight;

        // Determine state: connecting (yellow), connected (green), unstable (orange/question-mark-circle), or broken (red)
        if (connectionState === 'connecting') {
            connectionEl.setAttribute('aria-label', 'Connection status: connecting');
            connectionEl.setAttribute('title', 'WebSocket connection: connecting');
            // Re-enable animation for connecting state
            connectingIcon.style.animation = '';
            connectingIcon.style.display = '';
            if (liveRegion) liveRegion.textContent = 'Connection status: connecting';
        } else if (connectionState === 'connected') {
            connectionEl.setAttribute('aria-label', 'Connection status: connected');
            connectionEl.setAttribute('title', 'WebSocket connection: connected');
            // Ensure animation is removed for connected state
            connectingIcon.style.animation = 'none';
            connectedIcon.style.display = '';
            if (liveRegion) liveRegion.textContent = 'Connection status: connected';
        } else if (connectionState === 'unstable') {
            connectionEl.setAttribute('aria-label', 'Connection status: unstable');
            connectionEl.setAttribute('title', 'WebSocket connection: unstable - updates may be delayed or incomplete');
            // Re-enable animation for unstable state
            unstableIcon.style.animation = '';
            unstableIcon.style.display = '';
            if (liveRegion) liveRegion.textContent = 'Connection status: unstable';
        } else { // broken
            connectionEl.setAttribute('aria-label', 'Connection status: disconnected');
            connectionEl.setAttribute('title', 'WebSocket connection: disconnected');
            // Ensure animation is removed for broken state
            connectingIcon.style.animation = 'none';
            unstableIcon.style.animation = 'none';
            disconnectedIcon.style.display = '';
            if (liveRegion) liveRegion.textContent = 'Connection status: disconnected';
        }
    }

    // Restore connection state from data attribute after DOM updates
    function restoreConnectionState() {
        const connectionEl = document.getElementById('connection-status');
        if (connectionEl) {
            const savedState = connectionEl.getAttribute('data-connection-state');
            if (savedState && (savedState === 'connecting' || savedState === 'connected' || savedState === 'unstable' || savedState === 'broken')) {
                // Only restore if we don't have a more recent state
                // This prevents overwriting a newer state with an older one
                if (connectionState === 'connecting' && savedState !== 'connecting') {
                    connectionState = savedState;
                } else if (connectionState !== savedState && savedState !== 'connecting') {
                    // If saved state is more definitive (connected/unstable/broken), use it
                    connectionState = savedState;
                }
            }
        }
    }

    // Refresh countdown circle - synchronized with server updates
    let countdownInitialized = false;
    let countdownCircle = null;
    let circumference = 0;
    let lastServerUpdateTime = null; // Track server's last_update to detect real data updates

    function initRefreshCountdown() {
        const circle = document.querySelector('.refresh-countdown circle.progress');
        if (!circle) {
            // console.warn('Countdown circle not found yet, will retry');
            // Retry after a short delay if element not found
            setTimeout(initRefreshCountdown, 100);
            return;
        }
        countdownCircle = circle;

        // Only initialize circumference and startCountdown function once
        if (!countdownInitialized) {
            countdownInitialized = true;
            const radius = 5; // Smaller radius to match reduced icon size
            circumference = 2 * Math.PI * radius;

            // Define startCountdown and make it accessible globally
            startCountdown = function() {
                // Re-query the element in case DOM was updated by pyview
                const circle = document.querySelector('.refresh-countdown circle.progress');
                if (!circle) {
                    // console.warn('Countdown circle not found, cannot start countdown');
                    return;
                }
                countdownCircle = circle;

                // Ensure circumference is set
                if (circumference === 0) {
                    const radius = 5;
                    circumference = 2 * Math.PI * radius;
                }
                circle.setAttribute('stroke-dasharray', circumference);

                // Clear any existing interval
                if (countdownInterval) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                }

                countdownElapsed = 0;
                countdownRunning = true;
                // Reset the circle to full (offset = 0 means full circle)
                circle.setAttribute('stroke-dashoffset', '0');
                const updateInterval = 100; // Update every 100ms for smooth animation

                function updateCountdown() {
                    // Re-query element in case it was replaced during countdown
                    const circle = document.querySelector('.refresh-countdown circle.progress');
                    if (!countdownRunning || !circle) return;

                    countdownElapsed += updateInterval;
                    const progress = countdownElapsed / (REFRESH_INTERVAL_SECONDS * 1000);
                    const offset = circumference * (1 - progress);
                    circle.setAttribute('stroke-dashoffset', offset.toString());

                    // Update screen reader text with remaining time
                    const remainingSeconds = Math.ceil((REFRESH_INTERVAL_SECONDS * 1000 - countdownElapsed) / 1000);
                    const srText = document.getElementById('refresh-countdown-sr');
                    if (srText && remainingSeconds > 0) {
                        srText.textContent = `Refresh countdown: ${remainingSeconds} seconds remaining`;
                    }

                    // When countdown reaches the end, stop and wait for next update
                    if (countdownElapsed >= REFRESH_INTERVAL_SECONDS * 1000) {
                        countdownRunning = false;
                        clearInterval(countdownInterval);
                        countdownInterval = null;
                        // Update screen reader text
                        const srTextFinal = document.getElementById('refresh-countdown-sr');
                        if (srTextFinal) {
                            srTextFinal.textContent = 'Refresh countdown: updating';
                        }
                        // Check if we're overdue for an update
                        const timeSinceLastUpdate = Date.now() - lastUpdateTime;
                        if (timeSinceLastUpdate > REFRESH_INTERVAL_SECONDS * 1000 * 1.5) {
                            // console.warn('No update received - server may not be sending updates');
                            // Don't mark as error immediately, just log warning
                            // The connection status will show if WebSocket is disconnected
                        }
                    }
                }

                countdownInterval = setInterval(updateCountdown, updateInterval);
                // console.log('Countdown started');
            }
        }

        // On initial load, start the countdown
        if (startCountdown) {
            startCountdown();
        }
    }

    // Set up event listeners once (outside initRefreshCountdown)
    window.addEventListener('phx:error', (event) => {
        try {
            console.error('phx:error received:', event);
            // Increment failed update count
            failedUpdateCount++;
        
        // If we've had multiple errors, mark as unstable
        // If errors persist, mark as broken
        if (failedUpdateCount >= 3) {
            connectionState = 'broken';
        } else if (failedUpdateCount >= 1) {
            connectionState = 'unstable';
        }
        
        // PyView handles reconnection automatically - no custom timeout needed
        // Use requestAnimationFrame to ensure DOM is ready
        requestAnimationFrame(() => {
            updateConnectionStatus();
            updateApiStatus('error');
            if (connectionState === 'broken') {
                hidePresenceCount();
            }
        });
        // Stop countdown on error
        if (countdownInterval) {
            clearInterval(countdownInterval);
            countdownInterval = null;
            countdownRunning = false;
        }
        } catch (e) {
            console.error('Error in phx:error handler:', e);
            throw e; // Re-throw to maintain observability
        }
    });

    window.addEventListener('phx:update', (event) => {
        try {
            // console.log('phx:update received', event);
            // Data was successfully fetched - connection is working
            const now = Date.now();
        const timeSinceLastUpdate = now - lastUpdateTime;
        
        // Check if this is a delayed or botched update
        // If updates are coming but with significant delays (>2x expected interval), mark as unstable
        const expectedInterval = REFRESH_INTERVAL_SECONDS * 1000;
        if (timeSinceLastUpdate > expectedInterval * 2.5 && lastUpdateTime > 0) {
            // Updates are delayed - connection is unstable
            connectionState = 'unstable';
            failedUpdateCount = 0; // Reset failed count since we got an update
        } else {
            // Normal update - connection is good
            connectionState = 'connected';
            failedUpdateCount = 0;
        }
        
        lastUpdateTime = now;
        lastSuccessfulUpdate = now;

        // PyView handles reconnection - no custom timeout to clear

        // Clear update timeout and set a new one to detect if updates stop
        if (updateTimeout) {
            clearTimeout(updateTimeout);
        }
        // If we don't receive an update within 10 seconds, mark as unstable first
        // Then if still no update after 20 seconds, mark as broken
        updateTimeout = setTimeout(() => {
            const timeSinceLastSuccessful = Date.now() - lastSuccessfulUpdate;
            if (timeSinceLastSuccessful > 20000) {
                // No updates for 20+ seconds - fully broken
                connectionState = 'broken';
            } else if (timeSinceLastSuccessful > 10000) {
                // No updates for 10+ seconds - unstable
                connectionState = 'unstable';
            }
            requestAnimationFrame(() => {
                updateConnectionStatus();
                if (connectionState === 'broken') {
                    hidePresenceCount();
                }
            });
        }, 10000); // Check every 10 seconds

        // Check if update is botched (contains undefined values or errors)
        // This detects when the server sends an update but it's malformed
        setTimeout(() => {
            const departuresEl = document.getElementById('departures');
            if (departuresEl) {
                const content = departuresEl.textContent || '';
                // If we see "undefined" in the content, the update was botched
                if (content.includes('undefined') || content.trim() === 'undefined') {
                    // Botched update - mark as unstable
                    connectionState = 'unstable';
                    failedUpdateCount++;
                    requestAnimationFrame(() => {
                        updateConnectionStatus();
                    });
                }
            }
        }, 100); // Check after DOM update completes

        // Update connection status after DOM update (pyview may have replaced elements)
        // Use multiple requestAnimationFrame calls and a small timeout to ensure DOM is fully updated
        // pyview patches DOM, then we need to wait for it to complete before updating status
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                // Additional small delay to ensure pyview's DOM patch is complete
                setTimeout(() => {
                    // Don't restore connection state on phx:update - it might restore stale "connected" state
                    // The connection state is managed by phx:disconnect, phx:connecting, phx:open, phx:close events
                    // Only update UI if connectionState was set by those events
                    // Re-query elements in case they were replaced and update status
                    updateConnectionStatus();
                    // Do NOT read from event.detail - PyView manages assigns through DOM
                    // API status and presence are rendered by PyView from server assigns
                }, 10); // Small delay to ensure DOM patch is complete
            });
        });

        // Handle pagination if enabled
        if (PAGINATION_ENABLED) {
            initPagination();
        }

        // Re-initialize time format toggle after DOM update
        requestAnimationFrame(() => {
            initTimeFormatToggle();
        });

        // Re-check destination scrolling after DOM update
        requestAnimationFrame(() => {
            initDestinationScrolling();
        });

        // Immediately update datetime display (before delay)
        // This ensures it's visible right away, even if pyview replaced it
        requestAnimationFrame(() => {
            updateDateTime();
        });

        // Check if we got a new data update by comparing server's last_update timestamp
        setTimeout(() => {
            // Re-query the countdown circle in case it was replaced by DOM diff
            const countdownEl = document.querySelector('.refresh-countdown');
            const circle = countdownEl ? countdownEl.querySelector('circle.progress') : null;

            if (!circle || !countdownEl) {
                // console.warn('Countdown circle not found after phx:update, will retry');
                // Retry initialization
                initRefreshCountdown();
                return;
            }

            // Get the server's last_update timestamp from the data attribute
            const serverUpdateTime = countdownEl.getAttribute('data-last-update');
            const newServerUpdateTime = serverUpdateTime ? parseInt(serverUpdateTime, 10) : null;

            // Only restart countdown if the server's last_update timestamp actually changed
            // This ensures we only restart on real data updates, not just DOM refreshes
            if (newServerUpdateTime && newServerUpdateTime !== lastServerUpdateTime) {
                lastServerUpdateTime = newServerUpdateTime;

                if (countdownInitialized && startCountdown) {
                    // console.log('Restarting countdown - new data update received');
                    startCountdown();
                } else {
                    // Initialize if not already done
                    initRefreshCountdown();
                }
            } else if (!countdownInitialized) {
                // Initialize on first load even if timestamp hasn't changed
                initRefreshCountdown();
                if (newServerUpdateTime) {
                    lastServerUpdateTime = newServerUpdateTime;
                }
            }
        }, 50); // Small delay to ensure DOM patch is complete
        } catch (e) {
            console.error('Error in phx:update handler:', e, event);
            throw e; // Re-throw to maintain observability
        }
    });

    // Presence count is managed entirely by PyView - do not modify DOM

    function updateApiStatus(status) {
            const apiSuccessIcon = document.getElementById('api-success-icon');
            const apiErrorIcon = document.getElementById('api-error-icon');
            const apiUnknownIcon = document.getElementById('api-unknown-icon');
            const apiStatusContainer = document.getElementById('api-status-container');
            const liveRegion = document.getElementById('aria-live-status');

            if (!apiSuccessIcon || !apiErrorIcon || !apiUnknownIcon) {
                // console.warn('API status icons not found');
                return;
            }

            // Hide all icons first
            apiSuccessIcon.style.display = 'none';
            apiErrorIcon.style.display = 'none';
            apiUnknownIcon.style.display = 'none';

            // Show appropriate icon based on status
            if (status === 'success') {
                if (apiStatusContainer) {
                    apiStatusContainer.setAttribute('aria-label', 'API status: success');
                    apiStatusContainer.setAttribute('title', 'MVG API connection: success');
                }
                apiSuccessIcon.style.display = '';
                if (liveRegion) liveRegion.textContent = 'API status: success';
            } else if (status === 'error') {
                if (apiStatusContainer) {
                    apiStatusContainer.setAttribute('aria-label', 'API status: error');
                    apiStatusContainer.setAttribute('title', 'MVG API connection: error');
                }
                apiErrorIcon.style.display = '';
                if (liveRegion) liveRegion.textContent = 'API status: error';
            } else {
                if (apiStatusContainer) {
                    apiStatusContainer.setAttribute('aria-label', 'API status: unknown');
                    apiStatusContainer.setAttribute('title', 'MVG API connection: status unknown');
                }
                apiUnknownIcon.style.display = '';
                if (liveRegion) liveRegion.textContent = 'API status: unknown';
            }
        }

        // No custom reconnection logic - PyView handles reconnection automatically
        // We just listen to the events: phx:disconnect -> phx:connecting -> phx:open

    window.addEventListener('phx:disconnect', () => {
        try {
            console.log('phx:disconnect received - connection disconnected, PyView will attempt to reconnect');
            // On disconnect, set to connecting - PyView will automatically try to reconnect
            // This is NOT a permanent disconnect, just a temporary loss of connection
            connectionState = 'connecting';
            // Update UI immediately - don't wait for requestAnimationFrame
            updateConnectionStatus();
            
        // Clear update timeout since we're disconnected
        if (updateTimeout) {
            clearTimeout(updateTimeout);
            updateTimeout = null;
        }
        // Also update in next frame to ensure it sticks
        requestAnimationFrame(() => {
            updateConnectionStatus();
            hidePresenceCount(); // Hide presence while disconnected/reconnecting
        });
        // Stop countdown on disconnect - will restart when reconnected via phx:open
        if (countdownInterval) {
            clearInterval(countdownInterval);
            countdownInterval = null;
            countdownRunning = false;
        }
        } catch (e) {
            console.error('Error in phx:disconnect handler:', e);
            throw e;
        }
    });

    // Handle permanent connection close (no reconnection will be attempted)
    window.addEventListener('phx:close', () => {
        try {
            // console.log('phx:close received - connection permanently closed, no reconnection');
            // This is a permanent close - PyView will NOT attempt to reconnect
            connectionState = 'broken';
        // Clear update timeout since connection is closed
        if (updateTimeout) {
            clearTimeout(updateTimeout);
            updateTimeout = null;
        }
        // Use requestAnimationFrame to ensure DOM is ready
        requestAnimationFrame(() => {
            updateConnectionStatus();
            hidePresenceCount();
            // console.log('Connection status updated to broken (red), presence hidden');
        });
        // Stop countdown
        if (countdownInterval) {
            clearInterval(countdownInterval);
            countdownInterval = null;
            countdownRunning = false;
        }
        } catch (e) {
            console.error('Error in phx:close handler:', e);
            throw e;
        }
    });

    // Detect connecting state (when WebSocket is connecting/reconnecting)
    window.addEventListener('phx:connecting', () => {
        try {
            // console.log('phx:connecting received - attempting to reconnect');
            connectionState = 'connecting';
        // Use requestAnimationFrame to ensure DOM is ready
        requestAnimationFrame(() => {
            updateConnectionStatus();
            hidePresenceCount(); // Hide presence while connecting
            // console.log('Connection status updated to connecting (yellow, pulsating), presence hidden');
        });
        // PyView handles reconnection automatically - just update UI to show connecting state
        } catch (e) {
            console.error('Error in phx:connecting handler:', e);
            throw e;
        }
    });

    // Detect when WebSocket opens (connected or reconnected)
    window.addEventListener('phx:open', () => {
        try {
            // console.log('phx:open received - WebSocket connected/reconnected');
            connectionState = 'connected';
            // Reset failed update count on successful connection
            failedUpdateCount = 0;
        // PyView handles reconnection - no custom timeout to clear
        // Use requestAnimationFrame to ensure DOM is ready after pyview updates
        requestAnimationFrame(() => {
            updateConnectionStatus();
            // Presence will be shown when phx:update is received with actual data
            // console.log('Connection status updated to connected (green)');
        });
        // Restart countdown when connection opens/reopens
        if (countdownInitialized && startCountdown) {
            startCountdown();
        }
        } catch (e) {
            console.error('Error in phx:open handler:', e);
            throw e;
        }
    });

    // Initial state: connecting (will change to connected on first phx:update or phx:open)
    // Update connection status immediately on page load
    // Use requestAnimationFrame to ensure DOM is ready
    requestAnimationFrame(() => {
        updateConnectionStatus();
        updateApiStatus(INITIAL_API_STATUS); // Use initial API status from server
    });

    // Cleanup on unload
    window.addEventListener('beforeunload', () => {
        if (countdownInterval) {
            clearInterval(countdownInterval);
        }
        // No reconnectTimeout - PyView handles reconnection
        if (updateTimeout) {
            clearTimeout(updateTimeout);
        }
        if (timeFormatToggleInterval) {
            clearInterval(timeFormatToggleInterval);
        }
    });

    // Note: phx:update handling is done in the main phx:update listener above

    function createCountdownCircle(radius = 5) {
        const circumference = 2 * Math.PI * radius;
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('viewBox', '0 0 12 12');
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', '6');
        circle.setAttribute('cy', '6');
        circle.setAttribute('r', radius.toString());
        circle.setAttribute('stroke-dasharray', circumference.toString());
        circle.setAttribute('stroke-dashoffset', '0');
        svg.appendChild(circle);
        return { svg, circle, circumference };
    }

    function updateCountdown(circle, circumference, elapsed, total) {
        const progress = elapsed / total;
        const offset = circumference * (1 - progress);
        circle.setAttribute('stroke-dashoffset', offset.toString());
    }

    function initPagination() {
        // Paginate departures within route groups
        document.querySelectorAll('.route-group').forEach(group => {
            const departures = group.querySelectorAll('.departure-row');
            if (departures.length <= DEPARTURES_PER_PAGE) return;

            let currentPage = 0;
            const totalPages = Math.ceil(departures.length / DEPARTURES_PER_PAGE);

            // Create pagination indicator
            const indicator = document.createElement('div');
            indicator.className = 'pagination-indicator';
            indicator.setAttribute('role', 'status');
            indicator.setAttribute('aria-live', 'polite');
            indicator.setAttribute('aria-label', `Pagination: page ${currentPage + 1} of ${totalPages}`);
            const { svg, circle, circumference } = createCountdownCircle(5);
            svg.setAttribute('aria-hidden', 'true');
            indicator.appendChild(svg);
            const pageText = document.createElement('span');
            pageText.textContent = `${currentPage + 1}/${totalPages}`;
            pageText.setAttribute('aria-hidden', 'true');
            indicator.appendChild(pageText);
            const countdownText = document.createElement('span');
            countdownText.className = 'countdown-text';
            countdownText.textContent = `${PAGE_ROTATION_SECONDS}s`;
            countdownText.setAttribute('aria-hidden', 'true');
            indicator.appendChild(countdownText);
            // Add screen reader text
            const srText = document.createElement('span');
            srText.className = 'sr-only';
            srText.id = `pagination-sr-${Date.now()}`;
            srText.textContent = `Page ${currentPage + 1} of ${totalPages}`;
            indicator.appendChild(srText);
            group.appendChild(indicator);

            // Create pages
            for (let i = 0; i < totalPages; i++) {
                const page = document.createElement('div');
                page.className = 'pagination-page' + (i === 0 ? ' active' : '');
                const start = i * DEPARTURES_PER_PAGE;
                const end = start + DEPARTURES_PER_PAGE;
                for (let j = start; j < end && j < departures.length; j++) {
                    page.appendChild(departures[j].cloneNode(true));
                }
                group.appendChild(page);
            }

            // Hide original departures
            departures.forEach(d => d.style.display = 'none');

            // Countdown timer
            let elapsed = 0;
            const updateInterval = 100; // Update every 100ms for smooth animation
            const countdownInterval = setInterval(() => {
                elapsed += updateInterval;
                updateCountdown(circle, circumference, elapsed, PAGE_ROTATION_SECONDS * 1000);
                const remaining = Math.ceil((PAGE_ROTATION_SECONDS * 1000 - elapsed) / 1000);
                countdownText.textContent = `${Math.max(0, remaining)}s`;
                if (elapsed >= PAGE_ROTATION_SECONDS * 1000) {
                    elapsed = 0;
                }
            }, updateInterval);

            // Rotate pages
            const pageInterval = setInterval(() => {
                const pages = group.querySelectorAll('.pagination-page');
                if (pages.length === 0) {
                    clearInterval(pageInterval);
                    clearInterval(countdownInterval);
                    return;
                }
                pages[currentPage].classList.remove('active');
                currentPage = (currentPage + 1) % totalPages;
                pages[currentPage].classList.add('active');
                pageText.textContent = `${currentPage + 1}/${totalPages}`;
                countdownText.textContent = `${PAGE_ROTATION_SECONDS}s`;
                elapsed = 0; // Reset countdown
                // Update ARIA labels
                indicator.setAttribute('aria-label', `Pagination: page ${currentPage + 1} of ${totalPages}`);
                const srText = indicator.querySelector('.sr-only');
                if (srText) {
                    srText.textContent = `Page ${currentPage + 1} of ${totalPages}`;
                }
            }, PAGE_ROTATION_SECONDS * 1000);

            // Store intervals for cleanup
            if (!window._paginationIntervals) {
                window._paginationIntervals = [];
            }
            window._paginationIntervals.push(pageInterval, countdownInterval);
        });

        // Direction groups: no pagination, just scroll
        // Users can scroll vertically to see all direction groups
    }

    // Check and enable scrolling animation for clipped destination text
    function initDestinationScrolling() {
        document.querySelectorAll('.destination-text').forEach(textEl => {
            const container = textEl.closest('.destination');
            if (!container) return;
            // Check if text is clipped (text width > container width)
            const textWidth = textEl.scrollWidth;
            const containerWidth = container.clientWidth;
            const wasClipped = textEl.classList.contains('clipped');
            const isClipped = textWidth > containerWidth;

            if (isClipped) {
                // Text is clipped - add clipped class and calculate exact scroll distance
                const scrollDistance = containerWidth - textWidth;
                const currentScrollDistance = textEl.style.getPropertyValue('--scroll-distance');

                // Only update if clipping state changed or scroll distance changed significantly
                // This prevents restarting animation unnecessarily when time format changes
                if (!wasClipped || Math.abs(parseFloat(currentScrollDistance) - scrollDistance) > 1) {
                    textEl.classList.add('clipped');
                    // Set CSS variable with the exact scroll distance
                    textEl.style.setProperty('--scroll-distance', scrollDistance + 'px');
                }
            } else {
                // Text fits - remove clipped class
                if (wasClipped) {
                    textEl.classList.remove('clipped');
                    textEl.style.removeProperty('--scroll-distance');
                }
            }
        });
    }

    // Initialize on load
    function initializeAll() {
        if (PAGINATION_ENABLED) {
            initPagination();
        }
        // initRefreshCountdown will start the countdown automatically once initialized
        initRefreshCountdown();
        // Initialize time format toggle
        initTimeFormatToggle();
        // Initialize destination scrolling for clipped text
        initDestinationScrolling();
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeAll);
    } else {
        initializeAll();
    }

    // Cleanup intervals on page unload/disconnect
    window.addEventListener('beforeunload', () => {
        if (window._paginationIntervals) {
            window._paginationIntervals.forEach(interval => clearInterval(interval));
            window._paginationIntervals = [];
        }
    });

    // Also cleanup on LiveView disconnect
    window.addEventListener('phx:disconnect', () => {
        if (window._paginationIntervals) {
            window._paginationIntervals.forEach(interval => clearInterval(interval));
            window._paginationIntervals = [];
        }
    });
</script>
<!-- PyView client JavaScript - required for WebSocket connections -->
<!-- Verify CSRF token is available before loading client JS -->
<script>
    // Verify CSRF token exists
    const csrfMeta = document.querySelector("meta[name='csrf-token']");
    if (!csrfMeta) {
        // console.error('CSRF token meta tag not found!');
    } else {
        // console.log('CSRF token found:', csrfMeta.getAttribute('content'));
    }

    // Verify data-phx-main exists
    const phxMain = document.querySelector('[data-phx-main]');
    if (!phxMain) {
        // console.error('data-phx-main element not found!');
    } else {
        // console.log('data-phx-main element found');
    }

    // Load pyview client JS
    const script = document.createElement('script');
    script.src = '/static/assets/app.js';
    script.onerror = function() {
        // console.error('Failed to load /static/assets/app.js');
    };
    script.onload = function() {
        // console.log('app.js loaded successfully');
        // Connection status will be updated via phx:open/phx:close events
        // No need to check directly - observe events instead
    };
    document.body.appendChild(script);
</script>
</body>
</html>
    